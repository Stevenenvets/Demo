WITH V_NAV_TMP1 AS --计算每日单位净值，每日分红
 (SELECT N.ZHCODE,
         COALESCE(SN.C_CHILDCODE, N.C_FUNDCODE) AS C_FINGER_CODE,
         N.D_DATE,
         COALESCE(SN.F_UNITNAV, N.F_UNITNAV) AS F_UNITNAV,
         (COALESCE(SN.F_ACCUNITNAV, N.F_ACCUNITNAV) -
         COALESCE(SN.F_UNITNAV, N.F_UNITNAV)) AS F_ACCDIV
    FROM WJ_INVEST.FACT_INVEST_NAV N
    LEFT JOIN WJ_INVEST.FACT_INVEST_NAV_SUB SN
      ON N.ZHCODE = SN.ZHCODE
     AND N.D_DATE = SN.D_DATE
   INNER JOIN WJ_DM.DIM_SYS_TIME S
      ON N.D_DATE = TO_CHAR(S.D_DATE, 'YYYY-MM-DD')
     AND S.C_HOLIDAY_FLAG = '0'
   INNER JOIN WJ_INVEST.DIM_BASE_FUNDINFO F
      ON N.ZHCODE = F.ZHCODE
   INNER JOIN WJ_INVEST.DIM_BASE_TIMEFUNDINFO T
      ON F.ZHCODE = T.ZHCODE
   WHERE COALESCE(T.D_DEADLINE_DATE, '9999-12-31') >
         TO_CHAR(DATE_TRUNC('DAY', NOW()), 'YYYY-MM-DD')
     AND COALESCE(SN.C_CHILDCODE, N.C_FUNDCODE) = '013741'
     AND COALESCE(F.D_TRANS, T.D_CREATE_DATE) > '1900-01-01'
     AND ((F.C_TYPE IN ('GM', 'QD') AND
          (F.C_FULL_NAME LIKE '%定期%' OR F.C_INNER_TYPE = '1' OR
          T.D_CREATE_DATE >= '2020-06-01')) OR F.C_TYPE = 'ZH')),
V_NAV_TMP2 AS --计算前一日单位净值，每日分红
 (SELECT A.ZHCODE,
         A.C_FINGER_CODE,
         A.D_DATE,
         A.F_UNITNAV,
         LAG(A.F_UNITNAV) OVER(PARTITION BY A.ZHCODE, A.C_FINGER_CODE ORDER BY A.D_DATE) AS F_PRE_UNITNAV,
         A.F_ACCDIV,
         LAG(A.F_ACCDIV) OVER(PARTITION BY A.ZHCODE, A.C_FINGER_CODE ORDER BY A.D_DATE) AS F_PRE_ACCDIV
    FROM V_NAV_TMP1 A),
V_RETURN AS --计算每日收益率
 (SELECT A.ZHCODE,
         A.C_FINGER_CODE,
         A.D_DATE,
         (CASE
           WHEN (A.F_PRE_UNITNAV - A.F_ACCDIV + A.F_PRE_ACCDIV) = 0 THEN
            0
           ELSE
            COALESCE(A.F_UNITNAV /
                     (A.F_PRE_UNITNAV - A.F_ACCDIV + A.F_PRE_ACCDIV)
                     ::NUMERIC - 1,
                     0)
         END) AS F_RETURN
    FROM V_NAV_TMP2 A
   WHERE D_DATE BETWEEN
         TO_CHAR(WJ_DM.FNC_PRE_DATE(TO_DATE('${V_STARTDATE}', 'YYYY-MM-DD'),
                                    1) + 1,
                 'YYYY-MM-DD') AND '${V_ENDDATE}'),
V_PERFORMANCE AS
 (SELECT C_FINGER_CODE || '.OF' AS S_INFO_WINDCODE,
         REPLACE(D_DATE, '-', '') AS TRADE_DT,
         F_RETURN
    FROM V_RETURN),
V_NAV AS --计算每日单位净值
 (SELECT A.S_INFO_WINDCODE,
         A.TRADE_DT,
         EXP(SUM(LN(A.F_RETURN + 1))
             OVER(PARTITION BY A.S_INFO_WINDCODE ORDER BY A.TRADE_DT)) AS F_RETURN_N
    FROM V_PERFORMANCE A),
V_NAV2 AS --计算单位净值，按照当前日往后的最小净值（最大回撤日的净值（CURRENT ROW AND UNBOUNDED FOLLOWING 当前行到最后一行）），计算最大回撤幅度
 (SELECT A.S_INFO_WINDCODE,
         A.TRADE_DT,
         A.F_RETURN_N AS RTN,
         MIN(A.F_RETURN_N) OVER(PARTITION BY A.S_INFO_WINDCODE ORDER BY A.TRADE_DT ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS DRAWDOWN_GROUP,
         (A.F_RETURN_N - MIN(A.F_RETURN_N)
          OVER(PARTITION BY A.S_INFO_WINDCODE ORDER BY A.TRADE_DT
               ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)) /
         NULLIF(COALESCE(A.F_RETURN_N, 0), 0) ::NUMERIC AS RTN_DRAWDOWN --最大回撤
    FROM V_NAV A),
V_NAV3 AS --计算最大回撤日，根据最大回撤区间取最大日期，排序
 (SELECT S_INFO_WINDCODE,
         TRADE_DT,
         RTN_DRAWDOWN,
         MAX(CASE
               WHEN RTN = DRAWDOWN_GROUP THEN
                TRADE_DT
             END) OVER(PARTITION BY S_INFO_WINDCODE, DRAWDOWN_GROUP) AS DRAWDOWN_END_DATE,
         RANK() OVER(PARTITION BY S_INFO_WINDCODE ORDER BY RTN_DRAWDOWN DESC) AS RK
    FROM V_NAV2),
V_NAV4 AS --取最大回撤的区间数据
 (SELECT S_INFO_WINDCODE,
         ROUND(MAX(RTN_DRAWDOWN), 6) AS RTN_DRAWDOWN,
         DECODE(MAX(RTN_DRAWDOWN), 0, '-', MIN(TRADE_DT)) AS DRAWDOWN_BEGIN_DATE,
         DECODE(MAX(RTN_DRAWDOWN), 0, '-', MAX(DRAWDOWN_END_DATE)) AS DRAWDOWN_END_DATE
    FROM V_NAV3
   WHERE RK = 1
   GROUP BY S_INFO_WINDCODE)
SELECT H.S_INFO_WINDCODE AS 基金代码,
       H.RTN_DRAWDOWN AS 最大回撤,
       DECODE(DRAWDOWN_BEGIN_DATE,
              '-',
              '-',
              TO_CHAR(TO_DATE(H.DRAWDOWN_BEGIN_DATE, 'YYYYMMDD') + 1,
                      'YYYY/MM/DD') || '~' ||
              TO_CHAR(TO_DATE(H.DRAWDOWN_END_DATE, 'YYYYMMDD'), 'YYYY/MM/DD')) AS 最大回撤区间
  FROM V_NAV4 H;
--*********************************************************************************************--
--另外一种算法，未验证。根据A.COM_NET_DATE <= B.COM_NET_DATE 每天往前推，取最小的收益率（负数，即为最大回撤）
SELECT COMBINE_CODE, MIN(RE_TREAT) AS MAXRETREATRATIO
  FROM (SELECT A.*,
               B.COM_NET_DATE,
               DECODE(A.COM_NET_VALUE,
                      0,
                      0,
                      (B.COM_NET_VALUE / A.COM_NET_VALUE) - 1) AS RE_TREAT
          FROM (SELECT COM_NET_VALUE, COM_NET_DATE, C.COMBINE_CODE
                  FROM HS_ITS.ITS_HIS_COMB_PRICE C
                 WHERE MERCHANT_NO = '!'
                   AND C.COMBINE_CODE = 'LU000001'
                   AND C.COM_NET_DATE <= '20220630') A
          LEFT JOIN (SELECT COM_NET_VALUE, COM_NET_DATE, COMBINE_CODE
                      FROM HS_ITS.ITS_HIS_COMB_PRICE A
                     WHERE MERCHANT_NO = '!'
                       AND A.COM_NET_DATE <= '20220630') B
            ON A.COMBINE_CODE = B.COMBINE_CODE
           AND A.COM_NET_DATE <= B.COM_NET_DATE)
 WHERE COMBINE_CODE = 'LU000001'
 GROUP BY COMBINE_CODE;
--*********************************************************************************************--
--按照上面的计算方式可以用下面方法计算，但是迪卡尔乘积较大。
WITH V_NAV_TMP1 AS
 (SELECT N.ZHCODE,
         COALESCE(SN.C_CHILDCODE, N.C_FUNDCODE) AS C_FINGER_CODE,
         N.D_DATE,
         COALESCE(SN.F_UNITNAV, N.F_UNITNAV) AS F_UNITNAV,
         (COALESCE(SN.F_ACCUNITNAV, N.F_ACCUNITNAV) -
         COALESCE(SN.F_UNITNAV, N.F_UNITNAV)) AS F_ACCDIV
    FROM WJ_INVEST.FACT_INVEST_NAV N
    LEFT JOIN WJ_INVEST.FACT_INVEST_NAV_SUB SN
      ON N.ZHCODE = SN.ZHCODE
     AND N.D_DATE = SN.D_DATE
   INNER JOIN WJ_DM.DIM_SYS_TIME S
      ON N.D_DATE = TO_CHAR(S.D_DATE, 'YYYY-MM-DD')
     AND S.C_HOLIDAY_FLAG = '0'
   INNER JOIN WJ_INVEST.DIM_BASE_FUNDINFO F
      ON N.ZHCODE = F.ZHCODE
   INNER JOIN WJ_INVEST.DIM_BASE_TIMEFUNDINFO T
      ON F.ZHCODE = T.ZHCODE
   WHERE COALESCE(T.D_DEADLINE_DATE, '9999-12-31') >
         TO_CHAR(DATE_TRUNC('DAY', NOW()), 'YYYY-MM-DD')
     AND COALESCE(SN.C_CHILDCODE, N.C_FUNDCODE) = '013741'
     AND COALESCE(F.D_TRANS, T.D_CREATE_DATE) > '1900-01-01'
     AND ((F.C_TYPE IN ('GM', 'QD') AND
          (F.C_FULL_NAME LIKE '%定期%' OR F.C_INNER_TYPE = '1' OR
          T.D_CREATE_DATE >= '2020-06-01')) OR F.C_TYPE = 'ZH')),
V_NAV_TMP2 AS
 (SELECT A.ZHCODE,
         A.C_FINGER_CODE,
         A.D_DATE,
         A.F_UNITNAV,
         LAG(A.F_UNITNAV) OVER(PARTITION BY A.ZHCODE, A.C_FINGER_CODE ORDER BY A.D_DATE) AS F_PRE_UNITNAV,
         A.F_ACCDIV,
         LAG(A.F_ACCDIV) OVER(PARTITION BY A.ZHCODE, A.C_FINGER_CODE ORDER BY A.D_DATE) AS F_PRE_ACCDIV
    FROM V_NAV_TMP1 A),
V_RETURN AS
 (SELECT A.ZHCODE,
         A.C_FINGER_CODE,
         A.D_DATE,
         (CASE
           WHEN (A.F_PRE_UNITNAV - A.F_ACCDIV + A.F_PRE_ACCDIV) = 0 THEN
            0
           ELSE
            COALESCE(A.F_UNITNAV /
                     (A.F_PRE_UNITNAV - A.F_ACCDIV + A.F_PRE_ACCDIV)
                     ::NUMERIC - 1,
                     0)
         END) AS F_RETURN
    FROM V_NAV_TMP2 A
   WHERE D_DATE BETWEEN
         TO_CHAR(WJ_DM.FNC_PRE_DATE(TO_DATE('${V_STARTDATE}', 'YYYY-MM-DD'),
                                    1) + 1,
                 'YYYY-MM-DD') AND '${V_ENDDATE}'),
V_PERFORMANCE AS
 (SELECT C_FINGER_CODE || '.OF' AS S_INFO_WINDCODE,
         REPLACE(D_DATE, '-', '') AS TRADE_DT,
         F_RETURN
    FROM V_RETURN),
V_NAV AS
 (SELECT A.S_INFO_WINDCODE,
         A.TRADE_DT,
         EXP(SUM(LN(A.F_RETURN + 1))
             OVER(PARTITION BY A.S_INFO_WINDCODE ORDER BY A.TRADE_DT)) AS F_RETURN_N
    FROM V_PERFORMANCE A)
SELECT *
  FROM (SELECT A.S_INFO_WINDCODE,
               A.TRADE_DT AS DRAWDOWN_BEG,
               A.F_RETURN_N AS DRAWDOWN_BEGNET,
               B.TRADE_DT AS DRAWDOWN_END,
               B.F_RETURN_N AS DRAWDOWN_ENDNET,
               DECODE(A.F_RETURN_N, 0, 0, (B.F_RETURN_N / A.F_RETURN_N) - 1) AS DRAWDOWN_RATE,
               ROW_NUMBER() OVER(PARTITION BY A.S_INFO_WINDCODE ORDER BY DECODE(A.F_RETURN_N, 0, 0,(B.F_RETURN_N / A.F_RETURN_N) - 1)) AS RN
          FROM V_NAV A
          LEFT JOIN V_NAV B
            ON A.S_INFO_WINDCODE = B.S_INFO_WINDCODE
           AND A.TRADE_DT <= B.TRADE_DT) A
 WHERE RN = 1
